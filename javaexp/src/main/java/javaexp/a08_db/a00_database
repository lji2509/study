# Database 처리..
0. 환경 설정
1. dao 작성
	1) 공통 필드 선언
		Connection(연결객체),
		Statement(대화객체), PreparedStatement(준비된 대화객체)
		ResultSet(결과객체)
	2) 공통 연결메서드 선언
		driver 메모리 로딩
		DriverManager.getConnection("연결정보","계정","비번");
		예외 처리 : ClassNotFoundException, SQLException

2. 각 기능 메서드 처리
	1) 기본 조회 처리 메서드
		public 결과테이터처리객체	 기능메서드(검색에 필요한 객체){
			연결공통메서드 호출
			예외처리1
			대화객체생성
			sql 수행을 통한 결과객체 생성
			결과객체를 통한 데이터 처리(객체로 할당)
			예외처리2
				-자원해제
		}
		ex)
		public ArrayList<Emp> getEmpList(Emp sch){
			setConn();
			stmt = con.createStatement(); //전역필드에 대화객체 할당
			String sql = ""; //작성된 sql문
			rs = stmt.executeQuery(sql); // select 문의 실행 결과를 ResultSet 객체에 담기
			while(rs.next()){ //rs.next() : 행단위로 다음 행에 데이터가 있을 때까지 호출하는 작업
				rs.getString("컬럼명"); : 한행의 데이터 기준으로 해당 컬럼에 있는 데이터 가져오기
				
			}
			rs.close(); stmt.close(); con.close(); 연결된 자원의 해제..
			try{}catch(SQLException) 예외처리
			
		
		}
	2) 핵심 기능 처리를 위한 이해
		- 드라이버부터 시작하여 객체들이 생성되는 과정과 메모리를 해제하는 과정이 연경되어 있다는 개념이해
			생성순서
			DriverManger ==> Connection ==> Statement ==>ResultSet
			자원해제순서 
			ResultSet ==> Statement ==> Connection
		
		- 결과객체(ResultSet)의 데이터 처리 기능 메서드
			.next() : 행단위로 이동하게 처리해주는 메서드 , 다음 행에 데이터가 없을 때까지(boolean)
				while(rs.next()) 
			.getXXX("컬럼명") : 해당 컬럼의 데이터 유형과 select의 컬럼명 맞게 데이터를 가져온다
			.getXXX(index) : 해당 컬럼의 데이터 유형과 select로 나열된 순서(1)에 맞게
		
		- 예외처리
			: 자원의 해제에 대한 처리/기타 예외에 대한 처리
		- ResultSet을 VO객체에 할당하고 이 VO를 모아서 ArrayList<VO>에 할당하는 처리
			1) 처리할 단위 객체 클래스 선언하기
			2) 기본 생성자/set/get메서드 선언하기
			3) 메서드의 return 유형을 ArrayList로 선언하기
			4) while() 안에서 행단위로 생성하여 
				선언된 ArrayList에 할당하기..
	
	4) 기능 메서드 작성 순서
		- sql 작성 select * from emp where ename like '%||'A'||%';
			insert into emp values(emp_seq.nextval, '홍길동", '사원', 7991, sysdate, 3500, 1000, 10);
		- 기능메서드를 작성하기 위하여 사용할 return 할 단위 VO/변수 확인/클래스생성
			매개변수로 작성할 VO/변수 확인/클래스생성
			class Emp{} : 리턴할 단위 객체 ==> ArrayList<Emp>
			"사원명" : 매개변수로 작성할 객체 ==> String ename
		-기능메서드 선언
			public ArrayList<Emp> getEmpList(String ename){
				ArrayList<Emp> list = new ArrayList<Emp>();
				
				return list;
			}	
			public void insertEmp(Emp ins) {
			
			}
		-기능메서드 안에서 구현한 내용 처리
			# select
				연결처리
				sql 문자열로 선언(동적sql ==> 매개형태 sql)
					String sql = "select * from emp where ename like '%||'A'||%'";
				대화객체
				결과객체
				While(rs.next()){
					//단위객체를 생성자나 메서드로 만들고
					Emp emp = new Emp(rs.getInt("empno"), rs.getString("ename")...);
					list.add(emp);
				}  
				자원해제
				예외처리
			# DML(insert, update, delete)
				연결처리
				트랜젝션(자동 commit false)
				대화객체생성
					con.excuteUpdate(sql);
				commit 처리
				예외발생시
					rollback();

# 단계별 연습과제 
1. sql을 이용한 동적 sql 문자열 선언과 VO 만들기
	ex)public ArrayList<Job> getJobList(String job){
		ArrayList<Job> list = new ArrayList<Job>();
		return list;
	   }
	1) 리턴할 유형과 리턴할 객체
		기능메서드를 통해서 최종적으로 리턴할 객체를 의미한다
		ArrayList<Job> : 이차원의 테이블 형식의 데이터를 리턴할 때 사용
		ArrayList<Job> list : 객체의 선언과 생성
		return list; 메서드 마지막 코드로 리턴 처리
		select * froem emp
		where empno = 7780; //empno가 식별하는 key이기에 단일 데ㅔ이터만 나온다
	
	ex) public Emp getEmp(int empno){
			Emp emp =null;
			return emp;		
		}
		select count(*) from emp
		where deptno=10;
		
		public int getCount(int deptno){
			int cnt = 0;
			return cnt;
		}
	2) 여러가지 유형의 매개변수 처리
		#숫자형일때
		select *
		from emp
		where sal between 1000 and 2000;
		public ArratList<Emp> schEmpList(int fr_sal, int to_sal){
			String sql = "select *"+
						 "from emp "+
						 "where sal between "+fr_sal+" and "+to_sal;
		}
		
		#문자형일때
		select *
		from emp
		where ename = 'HIMAN'
		and job = '사원'
		
		public ArrayList<Emp> schEmpList2(String ename, String job){
			String sql = "select * "+
						 "from emp "+
						 "where ename = '"+ename+"'"; 작은따옴표 조심해서
						 "and job = '"+job+"'"; 
						 //숫자데이터와 문자열데이터 입력시, 동적 sql은 구분하여야한다
						 
		}
		
3. ResultSet 객체처리
	1) 기능메서드 이해
		rs.next() : 행단위 이동
		rs.getXXX("컬럼명") select 컬럼명	XXX는 해당 컬럼의 데이터유형
		while(rs.next()) {
			rs.getInt("empno")
		}
	2) 리턴할 VO/ArrayList/변수 할당
		public Emp XXXX()
			Emp e = null;
			if(rs.next()) { //변수나 행이 단일로 나올 때
				e = new Emp(rs.getInt("empno"),...);
			}
			public ArrayList<Emp> XXXX()
				ArrayList<Emp> list = new ArrayList<Emp>();
				while(rs.next()) {
					list.add(new Emp(rs.getInt("empno"),...));
				}